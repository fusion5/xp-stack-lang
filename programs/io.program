def rex_b = #01 (Permits access to registers r8-r15 of an operand).
def rex_x = #02 (Unknown).
def rex_r = #04 (Permits access to registers r8-r15 of an operand).
def rex_w = #08 (Indicates that the instruction is promoted to 64 bits).
def rex   = #20 (???).

def linux_sys_read = 3.
def linux_stdin = 0.

def emit_mov_rax_w64 = 
    (w64 -- )
    #48 emit_w8
    #B8 emit_w8
    emit_w64
.
def emit_mov_rdx_w64 =
    (w64 -- )
    #48 emit_w8
    #BA emit_w8
    emit_w64
.
def emit_mov_rbx_w64 = 
    (w64 -- )
    #48 emit_w8
    #BB emit_w8
    emit_w64
.
def emit_mov_rcx_rsi =
    ( -- )
    #48 emit_w8 
    #89 emit_w8 
    #F1 emit_w8
.
def emit_int = 
    ( -- )
    #CD emit_w8 
    #80 emit_w8 
.
def emit_ret = 
    ( -- )
    #C3 emit_w8
.
def emit_ppop_w8_to_cchar =
    ( -- )
    ( set the parser continuation character, r8 from the stack )
    ( mov r8, [rsi] )
    #4C emit_w8 
    #8B emit_w8 
    #06 emit_w8 
    ( add rsi, 8 )
    #48 emit_w8 #81 emit_w8 #C6 emit_w8  
    #08 emit_w8 #00 emit_w8 #00 emit_w8  #00 emit_w8 
.

def str_rd_w8 = #72 #64 #5F #77 #38 5
    ( the language don't have strings yet, so we encode "rd_w8" as 
      ascii bytes ) .

def define_rd_w8 =
    ( this is an example of a dynamic definition made possible
      by the primitives new_def and emit_w8 and emit_w64.
    )
    str_rd_w8 new_def
    ( add the definition of this term to the dictionary )

    ( the definition body follows: )
    #00 emit_ppush_w8 (emit allocation of 1 byte on the pstack)
    linux_sys_read emit_mov_rax_w64 (read system call)
    1              emit_mov_rdx_w64 (1 byte)
    linux_stdin    emit_mov_rbx_w64 (from stdin)
    emit_mov_rcx_rsi (instruct the system call to place the char 
                      at the top of the stack)
    emit_int
    emit_ppop_w8_to_cchar
    emit_ret
.

run define_rd_w8

def define_ppush_cchar_w8 =
    ( place the continuation character from reserved register r8
      into the stack as a w8 value )

    #70 #70 #75 #73 #68 #5F #63 #63 #68 #61 #72 #5F #77 #38 14 new_def
    ( "ppush_char_w8" encoded in ascii hex )

    #4C emit_w8 #89 emit_w8 #C0 emit_w8
    ( mov rax, r8 )

    #48 emit_w8 #81 emit_w8 #EE emit_w8 
        #01 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8
    ( sub rsi, 0x01 )

    #88 emit_w8 #46 emit_w8 #00 emit_w8 
    ( mov [rsi+0], al )

    emit_ret
    ( emit function return )
.

run define_ppush_cchar_w8

def def_ppush_r9 = 
    (save register r9 to the stack)

    #70 #70 #75 #73 #68 #5F #72 #39 8 new_def
    ( "ppush_r9" in ascii hex )
    
    #48 emit_w8 #81 emit_w8 #EE emit_w8 
        #08 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8 
    (sub rsi 8)
    #4C emit_w8 #89 emit_w8 #0E emit_w8
    (mov [RSI+0], RR9)
    (ppush r9)

    emit_ret
    ( emit function return )
.

run def_ppush_r9

def emit_if_start = 
    ( emit the code for the if start and push on the pstack a pointer to help 
      to find out the address at which the jump address should be written. )

    ( copy the top of the stack into rax )
    #48 emit_w8 #8B emit_w8 #06 emit_w8
    ( mov rax, [rsi] )
    
    #48 emit_w8 #3D emit_w8 
        #00 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8 
    ( cmp rax, 0x00 )
    ( compare rax to 0 )

    #0F emit_w8 #84 emit_w8 
        #00 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8
    ( we don't yet know the jump offset. To fill this
      out later in if_end, save the position at which the
      address is to be written, hence the r9 ppush.
      Recall that r9 is the pointer to the definition bodies.
      The offset is 0 now but it will overwritten.
      The offset is calculated from the position of JE, 0F 84 
    )

    ppush_r9
.

def def_if_start = 
    ( emit the code for the if start and push on the pstack a pointer to help 
      to find out the address at which the jump address should be written. )

    #69 #66 #5F #73 #74 #61 #72 #74 8 new_def
    ( "if_start" in ascii hex )

    ( copy the top of the stack into rax )
    #48 emit_w8 #8B emit_w8 #06 emit_w8
    ( mov rax, [rsi] )
    
    #48 emit_w8 #3D emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8 
    ( cmp rax, 0x00 )
    ( compare rax to 0 )

    #0F emit_w8 #84 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8
    ( we don't yet know the jump offset. To fill this
      out later in if_end, save the position at which the
      address is to be written, hence the r9 ppush.
      Recall that r9 is the pointer to the definition bodies.
      The offset is 0 now but it will overwritten.
      The offset is calculated from the position of JE, 0F 84 
    )

    ppush_r9
.

run def_if_start

def def_if_end =
    ( if_end is the counterpart of if_start... )
    ( it does not emit code itself; instead, it alters the Jump Equal
      instruction emitted by the paired if_start)
    ( on the stack is the r9 backup that allows us to calculate the
      relative offset at which to write the current r9. )
    ppush_r9
    minus

.

run def_if_end

q 

def if = 
    (should we introduce a 'parser' keyword that 
        dynamically instructs the parser what to do?
    )
    compiler {
        ( because of 'compiler', these instructions are executed by the compiler: )
        ( - on the same data stack though, so be careful! )
        emit_if_start
        parse_stmt
        emit_if_end
    }
.

def def_if = 
    (emit if start)
    parse_if_term (todo: rename parse_if_term to parse_stmt
        (a term, a literal, or a block))
    (emit if end)
.
 
def parse_success = 2.
def parse_reject  = 1.
def parse_fail    = 0.

def parse_09 = 
    ppush_cchar_w8
    ( test if the continuation character is in 0-9. )

    dup_w8 #30 gt_w8 ( 30 greater than cchar )
    if_top_nz {
        drop_w64 
        ( less than ascii '0' )
        parse_reject
        ret
    } 
    drop_w64

    dup_w8 #39 lt_w8 ( 39 less than cchar )
    if_top_nz {
        drop_w64
        parse_reject
        ret
    }
    drop_w64
    parse_success
.

   
def test_parser =
    rd_w8
    parse_09
.

run test_parser /
run dbg_dump_ptop_w64
run test_parser 0
run dbg_dump_ptop_w64
run test_parser 9
run dbg_dump_ptop_w64
run test_parser :
run dbg_dump_ptop_w64

q
