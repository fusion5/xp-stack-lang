def rex_b = #01 (Permits access to registers r8-r15 of an operand).
def rex_x = #02 (Unknown).
def rex_r = #04 (Permits access to registers r8-r15 of an operand).
def rex_w = #08 (Indicates that the instruction is promoted to 64 bits).
def rex   = #20 (???).

def linux_sys_read = 3.
def linux_stdin = 0.

def emit_mov_rax_w64 = 
    (w64 -- )
    #48 emit_w8
    #B8 emit_w8
    emit_w64
.
def emit_mov_rdx_w64 =
    (w64 -- )
    #48 emit_w8
    #BA emit_w8
    emit_w64
.
def emit_mov_rbx_w64 = 
    (w64 -- )
    #48 emit_w8
    #BB emit_w8
    emit_w64
.
def emit_mov_rcx_rsi =
    ( -- )
    #48 emit_w8 
    #89 emit_w8 
    #F1 emit_w8
.
def emit_int = 
    ( -- )
    #CD emit_w8 
    #80 emit_w8 
.
def emit_ret = 
    ( -- )
    #C3 emit_w8
.
def emit_ppop_w8_to_cchar =
    ( -- )
    ( set the parser continuation character, r8 from the stack )
    ( mov r8, [rsi] )
    #4C emit_w8 
    #8B emit_w8 
    #06 emit_w8 
    ( add rsi, 8 )
    #48 emit_w8 #81 emit_w8 #C6 emit_w8  
    #08 emit_w8 #00 emit_w8 #00 emit_w8  #00 emit_w8 
.

def str_rd_w8 = #72 #64 #5F #77 #38 5
    ( the language don't have strings yet, so we encode "rd_w8" as 
      ascii bytes ) .

def define_rd_w8 =
    ( this is an example of a dynamic definition made possible
      by the primitives new_def and emit_w8 and emit_w64.
    )
    str_rd_w8 new_def
    ( add the definition of this term to the dictionary )

    ( the definition body follows: )
    #00 emit_ppush_w8 (emit allocation of 1 byte on the pstack)
    linux_sys_read emit_mov_rax_w64 (read system call)
    1              emit_mov_rdx_w64 (1 byte)
    linux_stdin    emit_mov_rbx_w64 (from stdin)
    emit_mov_rcx_rsi (instruct the system call to place the char 
                      at the top of the stack)
    emit_int
    emit_ppop_w8_to_cchar
    emit_ret
.

run define_rd_w8

def define_ppush_cchar_w8 =
    ( place the continuation character from reserved register r8
      into the stack as a w8 value )

    #70 #70 #75 #73 #68 #5F #63 #63 #68 #61 #72 #5F #77 #38 14 new_def
    ( "ppush_char_w8" encoded in ascii hex )

    #4C emit_w8 #89 emit_w8 #C0 emit_w8
    ( mov rax, r8 )

    #48 emit_w8 #81 emit_w8 #EE emit_w8 
        #01 emit_w8 #00 emit_w8 #00 emit_w8 #00 emit_w8
    ( sub rsi, 0x01 )

    #88 emit_w8 #46 emit_w8 #00 emit_w8 
    ( mov [rsi+0], al )

    emit_ret
    ( emit function return )
.

run define_ppush_cchar_w8

def parse_success = 2.
def parse_reject  = 1.
def parse_fail    = 0.

def parse_09 = 
    ppush_cchar_w8
    ( test if the continuation character is in 0-9. )

    dup_w8 #30 gt_w8 ( 30 greater than cchar )
    if_top_nz {
        drop_w64 
        ( less than ascii '0' )
        parse_reject
        ret
    } 
    drop_w64

    dup_w8 #39 lt_w8 ( 39 less than cchar )
    if_top_nz {
        drop_w64
        parse_reject
        ret
    }
    drop_w64
    parse_success
.
    
def test_parser =
    rd_w8
    parse_09
.

run test_parser /
run dbg_dump_ptop_w64
run test_parser 0
run dbg_dump_ptop_w64
run test_parser 9
run dbg_dump_ptop_w64
run test_parser :
run dbg_dump_ptop_w64

q
