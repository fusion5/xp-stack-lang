module Main where

import System.Environment

import ASM.Datatypes
import ASM.Pretty
import ASM.ASM (compileASM)

import X64.Datatypes
import X64.X64
import X64.PE64

import Lang.Datatypes
import Lang.Linux
import Lang.Windows
import Lang.Lang
import Lang.BasicFunctions

import Data.Maybe (listToMaybe)
import Data.Word

import qualified Data.ByteString.Lazy as BS


setup :: Platform -> X64 ()
setup Linux = do 
    comment "Initialise the heap. brk(), the Linux system call for this"
    comment "has id number 45. We use the heap as a function parameter"
    comment "stack (pstack), i.e. it is used to pass parameters to functions."
    mov rax (I64 linux_sys_brk)
    mov rbx (I64 0)
    int

    comment "rax holds the program break address."
    mov rPstack rax 

    comment "A second brk() call is needed."
    mov rax (I64 linux_sys_brk) 
    comment "Set the heap start address as brk argument"
    mov rbx rPstack
    comment "Allocate 10k bytes for the pstack."
    add rbx (I32 $ fromIntegral pstackSizeBytes)
    int
    -- FIXME: If the heap alloc didn't work then this 
    -- should throw a segmentation fault.
    comment "The parameter stack grows from large to small, "
    comment "similar to the call stack. Therefore we start from "
    comment "the highest possible address."
    add rPstack (I32 $ fromIntegral pstackSizeBytes) 
    comment "Now, rPstack holds the pstack top."
    comment "Allocate executable memory in which we place the body of "
    comment "definitions generated by terms parsed in the REPL (at runtime)."
    comment "This is also called JIT ASM code. R9 is the dedicated register."
    comment "Retrieve the current memory break:"
    mov rax (I64 linux_sys_brk)
    mov rbx (I64 0) -- An rbx of 0 means that brk() returns the program break.
    int
    comment "rax now holds the program break."
    mov rDefBodies rax
    comment "rDefBodies (r15) now holds the area where new just-in-time "
    comment "function definitions are placed."

    {-
    do
        -- TEMP DEBUG
        ppush r9
        callLabel "dbg_dump_ptop_w64"
        writeMsgHelper "JIT start\n"
        pdrop 1
    -}

    mov rbx rax -- An rbx of the program break means that we wish to extend the
                -- program break
    add rbx (I32 10000) -- by 10k bytes
    mov rax (I64 linux_sys_brk)
    int
    comment "We've successfully allocated the memory for definitions in rDefBodies."
    comment "(Apparently it's writeable and executable by default)."
    comment "Allocate memory for the dictionary. The dictionary is a linked list"
    comment "With entries having fields [prev][hash][address], where:"
    comment "- prev is a pointer to the previous dictionary element."
    comment "- hash is the term hash."
    comment "- address is a pointer to the JIT definitions memory zone, the "
    comment "  definition contents."  
    mov rax (I64 linux_sys_brk)
    mov rbx (I64 0) -- An rbx of 0 means that brk() returns the program break.
    int
    comment "rax now holds the program break."
    mov rDictIdx rax
    comment "rDictIdx is our dictionary linked list end position pointer."
    
    mov rbx rax
    add rbx (I32 10000) -- 10k bytes for the dictionary linked list
    mov rax (I64 linux_sys_brk)
    int
    comment "We've successfully allocated memory for the dictionary linked list."
    comment "Add a first, dummy, empty term to mark the end of the list"
    mov (derefOffset rDictIdx 0)  (I32 0)
    mov (derefOffset rDictIdx 8)  (I32 0)
    mov (derefOffset rDictIdx 16) (I32 0)
    add rDictIdx (I32 24)
setup Windows = do

    comment "Ensure a 16-bit call stack alignment:"
    comment "The stack needs to be 16-byte aligned before each call."
    comment "In function bodies the stack begins as non-"
    comment "aligned, having the 8-byte instruction pointer on top."
    comment "Therefore, if the function calls other functions, it must"
    comment "align the stack."
    sub rsp (I32 0x08)

    comment "The PE64 header contains labels to the start and end of the "
    comment "memory space that the Windows loader reserves for the process "
    comment "for the purpose of storing parameter stack data and the "
    comment "dictionary definitions."
    comment "1. The parameter stack, going from large to small addresses as"
    comment "it grows:"
    mov rPstack (L64 "end_stack")

    comment "2. The dictionary entries: "
    comment "Initialise the dictionary pointer. The dictionary is a linked list"
    comment "of entries having fields [prev][hash][address], where:"
    comment "- prev is a pointer to the previous dictionary element."
    comment "- hash is the term hash."
    comment "- address is a pointer to the JIT definitions memory zone, the "
    comment "  definition contents."  
    comment "Each of these fields is 8 bytes long."
    mov rDictIdx (L64 "begin_stack")
    comment "Add a first, dummy, empty term to mark the end of the list."
    comment "The dictionary grows from small to large addresses:"
    mov (derefOffset rDictIdx 0)  (I32 0)
    mov (derefOffset rDictIdx 8)  (I32 0)
    mov (derefOffset rDictIdx 16) (I32 0)
    comment "We don't need to add the size of a new record here, because"
    comment "the add is done by the insert operation"

    comment "3. The dictionary bodies grow from small addresses to large "
    comment "addresses. They are situated in the .text segment just after "
    comment "the program code ends"
    mov rDefBodies (L64 "begin_generated_text")

    comment "4. Initialise the stdin and stdout handlers"
    comment "HANDLE GetStdHandle (DWORD nStdHandle)"
    comment "STD_INPUT_HANDLE  = -10"
    comment "STD_OUTPUT_HANDLE = -11"
    comment "STD_ERROR_HANDLE  = -12"
    comment "Aspects of the Windows x64 calling convention that are used in"
    comment "this program:"
    comment "* Parameter passing - integer params: registers rcx, rdx, r8, r9"
    comment "  The rest are passed on the stack"
    comment "* Return values - in rax if it fits 64 bits"

    comment "Another GetStdHandle call: get stdout"
    mov rax (L64 "GetStdHandle")
    mov rax (deref rax)
    comment "Add call stack shadow space (win x64 calling convention):"
    sub rsp (I32 0x20) 

    comment "The first function parameter"
    mov rcx (I64 windows_stdout_handle)
    call rax

    mov rbx (L64 "stdout")
    mov (deref rbx) rax 

    comment "Another GetStdHandle call: get stdin"

    mov rax (L64 "GetStdHandle")
    mov rax (deref rax)

    mov rcx (I64 windows_stdin_handle)
    call rax

    mov rbx (L64 "stdin")
    mov (deref rbx) rax 

    comment "Remove call stack shadow space"
    add rsp (I32 0x20)

mainBody :: Platform -> X64 ()
mainBody platform = do
    -- X64.X64.xor rax rax

    setup platform

    populateDictionaryKernel
    
    ppush (I8 0x32)
    callLabel "write_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    ppush (I8 0x33)
    callLabel "write_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    ppush (I8 0x34)
    callLabel "write_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    -- pdrop 1
    
    -- pdrop 1

    --ppush (I8 0x11)
    -- callLabel "dbg_dump_ptop_w8"

    -- callLabel "dbg_dump_ptop_w64"
    -- pdrop 1

    {-
    ppush (I8 0x31)
    callLabel "write_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    ppush (I8 0x30)
    callLabel "write_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    callLabel "read_w8"
    callLabel "dbg_dump_ptop_w64"
    pdrop 1

    callLabel "dbg_dump_ptop_w8"
    -}

    -- int3
    -- TODO: Find mov/call opcodes that to do this more neatly?
    mov rax (L64 "ExitProcess")
    mov rax (deref rax)

    comment "Shadow space (win x64 calling convention):"
    sub rsp (I32 0x20)

    comment "The first function parameter"
    mov rcx (I64 2129)
    call rax
    ret

    comment "Kernel function bodies (they should come after the main code so"
    comment "that they aren't executed by the main entry point)"
    baseDefBodies platform

binFile :: Platform -> X64 ()
binFile Windows = do
    pe64Header 
        (baseAddress Windows) 
        (fromIntegral pstackSizeBytes) 
        (fromIntegral dictBodySizeBytes)
        (mainBody Windows)
{-
assembly Linux = do
    elf64Header 
        (
            elf64ProgramHeader image_base
                (
                    do
                        runX64 $ x64 Linux
                        -- comment "The table of all collected strings:"
                        -- emitStringTable
                )
        )
    -- replaceProgSize -- TODO: Could be removed (by replacing it with label diffs)
    -- replaceLabels  image_base
    -- replaceStrRefs image_base
        where image_base = baseAddress Linux 
-}

baseAddress Windows =   0x400000
baseAddress Linux   = 0xC0000000

outputStdout platform f as = 
    case runASM_for_X64 (baseAddress platform) as of 
        Left err -> 
            putStrLn $ "Error: " ++ err
        Right s  -> do
            putStrLn $ f s

compiledASM platform = do
    runX64 $ binFile platform
    compileASM 

main :: IO ()
main = do
    args <- getArgs
    case listToMaybe args of
        Just "bootstrap_x86_windows_doc" 
            -> do
                case runASM_for_X64 (baseAddress Windows) (compiledASM Windows) of 
                    Left err -> 
                        putStrLn $ "Error: " ++ err
                    Right finalState -> do
                        putStrLn $ ASM.Pretty.asmHex finalState
        Nothing
            -> do 
                case runASM_for_X64 (baseAddress Windows) (compiledASM Windows) of 
                    Left err -> 
                        putStrLn $ "Error: " ++ err
                    Right finalState -> do
                        -- putStrLn $ ASM.Pretty.asmHex finalState
                        -- putStrLn "Compiled assembly output:"
                        -- putStrLn $ show $ resolved_asm finalState
                        putStrLn "Writing to main.exe..."
                        BS.writeFile "main.exe" $ resolved_asm finalState
                        {-
                        bs <- outputStdout Windows ASM.Pretty.asmHex $ do
                            runX64 (assembly Windows)
                            replaceLabels
                        putStrLn (show bs)
                        -}


