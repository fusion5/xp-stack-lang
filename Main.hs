{-# LANGUAGE ScopedTypeVariables #-}
module Main where

import System.Environment

import ASM.Datatypes        -- Common datatypes
import ASM.ASM
import ASM.Pretty       -- Print ASM with nice comments (documentation)
import ELFHeader        -- ELF header
-- import Linux         -- Linux constants
import X86.Datatypes    -- X86-specific assembly datatypes
import X86.X86          -- X86-specific assembly code
import X86.Tests        -- X86-specific test suite (with NASM commands)
-- import X86.Debug     -- X86-specific debug helper functions
-- import X86.Functions -- Functions
-- import X86.Types     -- Types for the functions
-- import X86.AST       -- Abstract syntax tree
--
import Data.Word

import Lang.Lang
import Lang.Datatypes
import Lang.Types
import Lang.Debug
import Lang.Linux
import Data.Bits

import Data.Maybe (listToMaybe)
import Data.List (intercalate)

initParamStack :: X86_64 ()
initParamStack = do
    docX86 "Initialise the heap. brk(), the Linux system call that does this"
    docX86 "has id number 45. We will use the heap as a function parameter"
    docX86 "stack (pstack), i.e. it is used to pass parameters to functions."
    mov rax (I64 linux_sys_brk)
    mov rbx (I64 0)
    int

    docX86 "rax holds the program break address."
    mov rsi rax 

    docX86 "A second brk() call is needed."
    mov rax (I64 linux_sys_brk) 
    docX86 "Set the heap start address as brk argument"
    mov rbx rsi
    docX86 "Allocate 10k bytes for the pstack."
    add rbx (I32 10000)
    int
    -- FIXME: If the heap alloc didn't work then this 
    -- should throw a segmentation fault.
    docX86 "The parameter stack grows from large to smal, "
    docX86 "similar to the call stack. Therefore we start from "
    docX86 "the highest possible address."
    add rsi (I32 10000) 
    docX86 "Now, rsi holds the pstack top."

initDynamicDefinitionsMemory :: X86_64 ()
initDynamicDefinitionsMemory = do
    docX86 "Allocate executable memory in which we place the body of "
    docX86 "definitions generated by terms parsed in the REPL (at runtime):"
    docX86 "Retrieve the current memory break:"
    mov rax (I64 linux_sys_brk)
    mov rbx (I64 0) -- An rbx of 0 means that brk() returns the program break.
    int
    docX86 "rax now holds the program break."
    mov r9  rax
    docX86 "r9 now holds the area where new just-in-time function definitions "
    docX86 "are placed."

    mov rbx rax -- An rbx of the program break means that we wish to extend the
                -- program break
    add rbx (I32 10000) -- by 10k bytes
    mov rax (I64 linux_sys_brk)    -- brk syscall
    int
    docX86 "We've successfully allocated the memory for definitions in r9."
    docX86 "Apparently it's writeable and executable by default."

mainLang = do
    docLang "Read from stdin the dict. entry that we should interpret."

    -- Test for input string 'abc'
    {-
    assertPtop 3 "Please input 3 chars"
    pdrop 1
    assertPtopW8 0x63 "Please input c third"
    pdropW8 1
    assertPtopW8 0x62 "Please input b second"
    pdropW8 1
    assertPtopW8 0x61 "Please input a first"
    -}

    -- x86 $ callLabel "HASH_TERM"

    -- assertPtop (fromIntegral $ fnv1 [0x61, 0x62, 0x63]) 
    --    "The hash should match the one computed in HS"

    pushBaseDict

    x86 $ initDynamicDefinitionsMemory

    -- Program entry point
    let mainTerm = "REPL"
    ppushStr mainTerm
    ppushI32 $ length mainTerm
    x86 $ callLabel "TERM_LOOK"
    assertPtop 1 "REPL dictionary entry must be in the dictionary!"
    docLang "Drop the success return code of TERM_LOOK:"
    pdrop 1
    docLang "Now take the '.addr' field from the dictionary term found by "
    docLang "TERM_LOOK:"
    ppop rax
    x86 $ mov rax (derefOffset rax 16)

    {-- Debugging, inspect rax:
    ppush rax
    x86 $ callLabel "DBG_DUMP_PTOP_64"
    -- The stack top now contains the address of the term. print it, it should
    -- match the first print.
    ppop rax
    -}

    docLang "Call REPL:"
    x86 $ call rax
    x86 $ callLabel "EXIT"

    defineBaseDefBodies

mainX86 = do
    mov rbp rsp
    initParamStack
    -- Run the language standard function definitions in the Lang monad
    (a, finalLangState) <- runLang mainLang
    return a

mainASM = do
    runX86 mainX86

assembly = do
    elf64Header $ programHeader vaddr_offset $ do
        mainASM 
        documentation "The string table with all collected strings:"
        emitStringTable
    replaceProgSize
    replaceLabels  vaddr_offset
    replaceStrRefs vaddr_offset
        where vaddr_offset = 0xC0000000

doAction f as = 
    case assemble as of 
        Left err -> 
            putStrLn $ "Error: " ++ err
        Right s  -> 
            putStrLn $ f s

main :: IO ()
main = do
    args <- getArgs
    case listToMaybe args of
        Nothing           -> doAction ASM.Pretty.asmBytesOnly assembly
        Just "dump_bytes" -> doAction ASM.Pretty.asmBytesOnly assembly
        Just "doc"        -> doAction ASM.Pretty.asmPretty    assembly
        Just "test_x86"   -> doAction ASM.Pretty.asmBytesOnly x86TestSuiteASM
        Just "test_x86_n" -> putStr   $ x86TestSuiteNASM
        Just x            -> putStrLn $ "Unknown option \"" ++ x ++ "\"" ++
                             " of (dump_bytes, doc, test_x86, test_x86_n)"

